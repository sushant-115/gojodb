package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

// // Put resolves the 'put' mutation. It calls the GojoDB API Service.
// func (r *mutationResolver) Put(ctx context.Context, key string, value string) (*model.Entry, error) {
// 	log.Printf("GraphQL: Resolving PUT for key: %s, value: %s", key, value)

// 	reqBody := APIRequest{
// 		Command: "PUT",
// 		Key:     key,
// 		Value:   value,
// 	}

// 	jsonBody, err := json.Marshal(reqBody)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to marshal PUT request: %w", err)
// 	}

// 	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
// 	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to send PUT request to API Service: %w", err)
// 	}
// 	defer resp.Body.Close()

// 	bodyBytes, err := io.ReadAll(resp.Body)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to read API Service response: %w", err)
// 	}

// 	var apiResp APIResponse
// 	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
// 		return nil, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
// 	}

// 	if apiResp.Status == "OK" {
// 		return &model.Entry{Key: key, Value: value}, nil
// 	} else {
// 		return nil, fmt.Errorf("API Service error for PUT %s=%s: %s", key, value, apiResp.Message)
// 	}
// }

// // Delete resolves the 'delete' mutation. It calls the GojoDB API Service.
// func (r *mutationResolver) Delete(ctx context.Context, key string) (bool, error) {
// 	log.Printf("GraphQL: Resolving DELETE for key: %s", key)

// 	reqBody := APIRequest{
// 		Command: "DELETE",
// 		Key:     key,
// 	}

// 	jsonBody, err := json.Marshal(reqBody)
// 	if err != nil {
// 		return false, fmt.Errorf("failed to marshal DELETE request: %w", err)
// 	}

// 	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
// 	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
// 	if err != nil {
// 		return false, fmt.Errorf("failed to send DELETE request to API Service: %w", err)
// 	}
// 	defer resp.Body.Close()

// 	bodyBytes, err := io.ReadAll(resp.Body)
// 	if err != nil {
// 		return false, fmt.Errorf("failed to read API Service response: %w", err)
// 	}

// 	var apiResp APIResponse
// 	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
// 		return false, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
// 	}

// 	if apiResp.Status == "OK" {
// 		return true, nil
// 	} else if apiResp.Status == "NOT_FOUND" {
// 		return false, nil // Key not found, so not deleted
// 	} else {
// 		return false, fmt.Errorf("API Service error for DELETE %s: %s", key, apiResp.Message)
// 	}
// }

// // ExecuteTransaction is the resolver for the executeTransaction field.
// func (r *mutationResolver) ExecuteTransaction(ctx context.Context, operations []*model.TransactionOperationInput) (*model.TransactionResult, error) {
// 	panic(fmt.Errorf("not implemented: ExecuteTransaction - executeTransaction"))
// }

// // AdminAssignSlotRange is the resolver for the adminAssignSlotRange field.
// func (r *mutationResolver) AdminAssignSlotRange(ctx context.Context, input model.AssignSlotRangeInput) (bool, error) {
// 	panic(fmt.Errorf("not implemented: AdminAssignSlotRange - adminAssignSlotRange"))
// }

// // AdminSetMetadata is the resolver for the adminSetMetadata field.
// func (r *mutationResolver) AdminSetMetadata(ctx context.Context, key string, value string) (bool, error) {
// 	panic(fmt.Errorf("not implemented: AdminSetMetadata - adminSetMetadata"))
// }

// // AdminSetPrimaryReplica is the resolver for the adminSetPrimaryReplica field.
// func (r *mutationResolver) AdminSetPrimaryReplica(ctx context.Context, input model.SetPrimaryReplicaInput) (bool, error) {
// 	panic(fmt.Errorf("not implemented: AdminSetPrimaryReplica - adminSetPrimaryReplica"))
// }

// // Get resolves the 'get' query. It calls the GojoDB API Service.
// func (r *queryResolver) Get(ctx context.Context, key string) (*model.Entry, error) {
// 	log.Printf("GraphQL: Resolving GET for key: %s", key)

// 	reqBody := APIRequest{
// 		Command: "GET",
// 		Key:     key,
// 	}

// 	jsonBody, err := json.Marshal(reqBody)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to marshal GET request: %w", err)
// 	}

// 	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
// 	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to send GET request to API Service: %w", err)
// 	}
// 	defer resp.Body.Close()

// 	bodyBytes, err := io.ReadAll(resp.Body)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to read API Service response: %w", err)
// 	}

// 	var apiResp APIResponse
// 	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
// 		return nil, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
// 	}

// 	if apiResp.Status == "OK" {
// 		return &model.Entry{Key: key, Value: apiResp.Message}, nil
// 	} else if apiResp.Status == "NOT_FOUND" {
// 		return nil, nil // Return nil Entry, nil error for not found
// 	} else {
// 		return nil, fmt.Errorf("API Service error for GET %s: %s", key, apiResp.Message)
// 	}
// }

// // GetRange is the resolver for the getRange field.
// func (r *queryResolver) GetRange(ctx context.Context, startKey string, endKey string) ([]*model.Entry, error) {
// 	panic(fmt.Errorf("not implemented: GetRange - getRange"))
// }

// // Status is the resolver for the status field.
// func (r *queryResolver) Status(ctx context.Context) (*model.StatusResponse, error) {
// 	panic(fmt.Errorf("not implemented: Status - status"))
// }

// // AdminGetNodeForKey is the resolver for the adminGetNodeForKey field.
// func (r *queryResolver) AdminGetNodeForKey(ctx context.Context, key string) (*model.NodeForKeyResponse, error) {
// 	panic(fmt.Errorf("not implemented: AdminGetNodeForKey - adminGetNodeForKey"))
// }

// // Mutation returns MutationResolver implementation.
// func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// // Query returns QueryResolver implementation.
// func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// type mutationResolver struct{ *Resolver }
// type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) Put(ctx context.Context, key string, value string) (*model.Entry, error) {
	log.Printf("GraphQL: Resolving PUT for key: %s, value: %s", key, value)

	reqBody := APIRequest{
		Command: "PUT",
		Key:     key,
		Value:   value,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal PUT request: %w", err)
	}

	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to send PUT request to API Service: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read API Service response: %w", err)
	}

	var apiResp APIResponse
	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
	}

	if apiResp.Status == "OK" {
		return &model.Entry{Key: key, Value: value}, nil
	} else {
		return nil, fmt.Errorf("API Service error for PUT %s=%s: %s", key, value, apiResp.Message)
	}
}
func (r *mutationResolver) Delete(ctx context.Context, key string) (bool, error) {
	log.Printf("GraphQL: Resolving DELETE for key: %s", key)

	reqBody := APIRequest{
		Command: "DELETE",
		Key:     key,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return false, fmt.Errorf("failed to marshal DELETE request: %w", err)
	}

	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
	if err != nil {
		return false, fmt.Errorf("failed to send DELETE request to API Service: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return false, fmt.Errorf("failed to read API Service response: %w", err)
	}

	var apiResp APIResponse
	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
		return false, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
	}

	if apiResp.Status == "OK" {
		return true, nil
	} else if apiResp.Status == "NOT_FOUND" {
		return false, nil // Key not found, so not deleted
	} else {
		return false, fmt.Errorf("API Service error for DELETE %s: %s", key, apiResp.Message)
	}
}
func (r *queryResolver) Get(ctx context.Context, key string) (*model.Entry, error) {
	log.Printf("GraphQL: Resolving GET for key: %s", key)

	reqBody := APIRequest{
		Command: "GET",
		Key:     key,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal GET request: %w", err)
	}

	httpClient := http.Client{Timeout: CLIENT_TIMEOUT}
	resp, err := httpClient.Post(API_SERVICE_URL, "application/json", bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to send GET request to API Service: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read API Service response: %w", err)
	}

	var apiResp APIResponse
	if err := json.Unmarshal(bodyBytes, &apiResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal API Service response: %w. Raw: %s", err, string(bodyBytes))
	}

	if apiResp.Status == "OK" {
		return &model.Entry{Key: key, Value: apiResp.Message}, nil
	} else if apiResp.Status == "NOT_FOUND" {
		return nil, nil // Return nil Entry, nil error for not found
	} else {
		return nil, fmt.Errorf("API Service error for GET %s: %s", key, apiResp.Message)
	}
}
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }
*/
